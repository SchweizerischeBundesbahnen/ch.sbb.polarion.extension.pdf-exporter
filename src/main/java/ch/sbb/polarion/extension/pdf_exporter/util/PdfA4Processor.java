package ch.sbb.polarion.extension.pdf_exporter.util;

import com.polarion.core.util.logging.Logger;
import lombok.experimental.UtilityClass;
import org.apache.pdfbox.Loader;
import org.apache.pdfbox.cos.COSArray;
import org.apache.pdfbox.cos.COSDictionary;
import org.apache.pdfbox.cos.COSName;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.PDDocumentInformation;
import org.apache.pdfbox.pdmodel.common.PDMetadata;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.VisibleForTesting;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import java.nio.charset.StandardCharsets;
import java.util.Calendar;
import java.util.UUID;

/**
 * Utility class for processing PDF/A-4 documents to ensure compliance with ISO 19005-4:2020 specification.
 * <p>
 * This processor fixes common compliance issues that may be present in PDF/A-4 documents generated by WeasyPrint
 * or after PDF merging operations:
 * <ul>
 *     <li>Updates PDF version to 2.0 (PDF/A-4 requires PDF 2.0 or higher)</li>
 *     <li>Manually fixes the PDF file header to "%PDF-2.0" (workaround for PDFBox 3.x limitation)</li>
 *     <li>Ensures PDF/A OutputIntent exists (creates default sRGB OutputIntent if missing)</li>
 *     <li>Removes non-compliant entries from document information dictionary (keeping only ModDate)</li>
 *     <li>Removes the Info key from trailer dictionary when no PieceInfo exists in document catalog</li>
 *     <li>Fixes XMP metadata to use correct pdfaid:rev format (four-digit year instead of revision number)</li>
 *     <li>Handles pdfaid:conformance based on conformance level:
 *         <ul>
 *             <li>Sets pdfaid:conformance="E" for PDF/A-4e (engineering)</li>
 *             <li>Sets pdfaid:conformance="F" for PDF/A-4f (embedded files)</li>
 *             <li>Removes pdfaid:conformance for PDF/A-4u (not allowed)</li>
 *         </ul>
 *     </li>
 * </ul>
 * <p>
 * Note: This processor creates a new PDF document with version 2.0 and copies all content from the original,
 * as PDFBox 3.x does not reliably update the PDF version in the file header. This approach also helps restore
 * OutputIntent that may be lost during PDF merging operations.
 */
@UtilityClass
public class PdfA4Processor {
    private static final Logger logger = Logger.getLogger(PdfA4Processor.class);
    private static final String PDF_A_4_REV_YEAR = "2020";
    private static final String PDFAID_REV = "pdfaid:rev";

    /**
     * Processes a PDF/A-4 document to fix compliance issues according to ISO 19005-4:2020.
     * <p>
     * This method creates a new PDF document with version 2.0 and copies all content from the original,
     * as PDFBox does not reliably update the PDF version in the file header when using save().
     *
     * @param pdfBytes the original PDF content
     * @return the processed PDF content with compliance fixes applied
     * @throws IOException if an error occurs during PDF processing
     */
    public byte[] processPdfA4(byte[] pdfBytes) throws IOException {
        return processPdfA4(pdfBytes, null);
    }

    /**
     * Processes a PDF/A-4 document to fix compliance issues according to ISO 19005-4:2020.
     * <p>
     * This method creates a new PDF document with version 2.0 and copies all content from the original,
     * as PDFBox does not reliably update the PDF version in the file header when using save().
     *
     * @param pdfBytes    the original PDF content
     * @param conformance the conformance level: "E" for engineering, "F" for embedded files, or null for basic (4u)
     * @return the processed PDF content with compliance fixes applied
     * @throws IOException if an error occurs during PDF processing
     */
    public byte[] processPdfA4(byte[] pdfBytes, @Nullable String conformance) throws IOException {
        try (PDDocument originalDoc = Loader.loadPDF(pdfBytes);
             PDDocument newDoc = new PDDocument();
             ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {

            // Copy all pages from original to new document
            for (int i = 0; i < originalDoc.getNumberOfPages(); i++) {
                newDoc.addPage(originalDoc.getPage(i));
            }

            // Copy document catalog properties
            copyDocumentCatalog(originalDoc, newDoc);

            // Ensure OutputIntent exists (create sRGB OutputIntent if missing)
            ensureOutputIntent(newDoc);

            // Fix document information dictionary
            fixDocumentInformation(newDoc);

            // Fix XMP metadata
            fixXmpMetadata(newDoc, conformance);

            // IMPORTANT: Set PDF version to 2.0 AFTER all content has been copied
            // This must be done last to prevent PDFBox from auto-downgrading the version
            newDoc.setVersion(2.0f);

            // Also set version in catalog dictionary
            COSDictionary catalog = newDoc.getDocumentCatalog().getCOSObject();
            catalog.setItem(COSName.VERSION, COSName.getPDFName("2.0"));

            logger.debug("Set PDF version to 2.0 for PDF/A-4 compliance");

            // Save the modified document
            newDoc.save(outputStream);
            byte[] pdfContent = outputStream.toByteArray();

            // WORKAROUND: PDFBox 3.x doesn't always write PDF 2.0 in the file header
            // Manually fix the header if needed
            return fixPdfHeader(pdfContent);
        }
    }

    /**
     * Fixes the PDF header to ensure it starts with "%PDF-2.0".
     * <p>
     * This is a workaround for PDFBox 3.x which doesn't always write PDF 2.0
     * in the file header even when setVersion(2.0f) is called.
     *
     * @param pdfBytes the PDF content
     * @return the PDF content with fixed header
     */
    @VisibleForTesting
    byte[] fixPdfHeader(byte[] pdfBytes) {
        // Check if header needs fixing
        if (pdfBytes.length < 10) {
            return pdfBytes; // PDF too small, leave as is
        }

        // Read current header
        String header = new String(pdfBytes, 0, Math.min(20, pdfBytes.length), StandardCharsets.UTF_8);
        if (header.startsWith("%PDF-2.")) {
            return pdfBytes; // Already PDF 2.x, no fix needed
        }

        if (!header.startsWith("%PDF-1.")) {
            logger.warn("Unexpected PDF header: " + header.substring(0, Math.min(10, header.length())));
            return pdfBytes; // Unexpected format, leave as is
        }

        // Find the end of the version line (EOL marker)
        int eolIndex = -1;
        for (int i = 0; i < Math.min(20, pdfBytes.length); i++) {
            if (pdfBytes[i] == '\n' || pdfBytes[i] == '\r') {
                eolIndex = i;
                break;
            }
        }

        if (eolIndex == -1) {
            logger.warn("Could not find EOL marker in PDF header");
            return pdfBytes; // No EOL found, leave as is
        }

        // Replace the header with "%PDF-2.0"
        byte[] newPdfBytes = new byte[pdfBytes.length];
        byte[] newHeader = "%PDF-2.0".getBytes(StandardCharsets.UTF_8);

        // Copy new header
        System.arraycopy(newHeader, 0, newPdfBytes, 0, newHeader.length);

        // Copy the rest of the PDF (from EOL onwards)
        System.arraycopy(pdfBytes, eolIndex, newPdfBytes, newHeader.length, pdfBytes.length - eolIndex);

        logger.debug("Fixed PDF header from PDF 1.x to PDF 2.0");
        return newPdfBytes;
    }

    /**
     * Copies document catalog properties from source to destination document.
     * This includes metadata, OutputIntents, Names (for embedded files), and other catalog-level properties.
     *
     * @param source      the source PDF document
     * @param destination the destination PDF document
     * @throws IOException if an error occurs during copying
     */
    @VisibleForTesting
    void copyDocumentCatalog(@NotNull PDDocument source, @NotNull PDDocument destination) throws IOException {
        copyXmpMetadata(source, destination);
        copyOutputIntents(source, destination);
        copyDocumentInformation(source, destination);
        copyEmbeddedFiles(source, destination);
        logger.debug("Copied document catalog from source to destination");
    }

    /**
     * Copies XMP metadata from source to destination document.
     *
     * @param source      the source PDF document
     * @param destination the destination PDF document
     * @throws IOException if an error occurs during copying
     */
    @VisibleForTesting
    void copyXmpMetadata(@NotNull PDDocument source, @NotNull PDDocument destination) throws IOException {
        PDMetadata sourceMetadata = source.getDocumentCatalog().getMetadata();
        if (sourceMetadata != null) {
            PDMetadata destMetadata = new PDMetadata(destination);
            destMetadata.importXMPMetadata(sourceMetadata.toByteArray());
            destination.getDocumentCatalog().setMetadata(destMetadata);
            logger.debug("Copied XMP metadata from source to destination");
        }
    }

    /**
     * Copies OutputIntents from source to destination document.
     * OutputIntents are critical for PDF/A compliance.
     *
     * @param source      the source PDF document
     * @param destination the destination PDF document
     */
    @VisibleForTesting
    void copyOutputIntents(@NotNull PDDocument source, @NotNull PDDocument destination) {
        COSDictionary sourceCatalog = source.getDocumentCatalog().getCOSObject();
        COSDictionary destCatalog = destination.getDocumentCatalog().getCOSObject();

        if (sourceCatalog.containsKey(COSName.OUTPUT_INTENTS)) {
            destCatalog.setItem(COSName.OUTPUT_INTENTS, sourceCatalog.getItem(COSName.OUTPUT_INTENTS));
            logger.debug("Copied OutputIntents from source to destination");
        }
    }

    /**
     * Copies document information from source to destination document.
     * Only ModificationDate is preserved to ensure PDF/A-4 compliance.
     *
     * @param source      the source PDF document
     * @param destination the destination PDF document
     */
    @VisibleForTesting
    void copyDocumentInformation(@NotNull PDDocument source, @NotNull PDDocument destination) {
        PDDocumentInformation sourceInfo = source.getDocumentInformation();
        if (sourceInfo != null) {
            // Copy only the fields we want to preserve
            PDDocumentInformation destInfo = new PDDocumentInformation();
            if (sourceInfo.getModificationDate() != null) {
                destInfo.setModificationDate(sourceInfo.getModificationDate());
            }
            destination.setDocumentInformation(destInfo);
            logger.debug("Copied document information from source to destination");
        }
    }

    /**
     * Copies embedded files (Names dictionary) from source to destination document.
     * This is required for PDF/A-4f compliance which mandates the EmbeddedFiles key.
     *
     * @param source      the source PDF document
     * @param destination the destination PDF document
     */
    @VisibleForTesting
    void copyEmbeddedFiles(@NotNull PDDocument source, @NotNull PDDocument destination) {
        COSDictionary sourceCatalog = source.getDocumentCatalog().getCOSObject();
        COSDictionary destCatalog = destination.getDocumentCatalog().getCOSObject();

        if (sourceCatalog.containsKey(COSName.NAMES)) {
            destCatalog.setItem(COSName.NAMES, sourceCatalog.getItem(COSName.NAMES));
            logger.debug("Copied Names dictionary (including EmbeddedFiles) from source to destination");
        }
    }

    /**
     * Ensures that the PDF document has an OutputIntent.
     * <p>
     * According to ISO 19005-4:2020 clause 6.2.9 and 6.2.4.3:
     * <ul>
     *     <li>If the document does not contain a PDF/A output intent, pages with transparency
     *     must have page-level output intent or Group key with CS entry</li>
     *     <li>DeviceRGB requires either DefaultRGB colour space, transparency blending space,
     *     or PDF/A OutputIntent with RGB destination profile</li>
     * </ul>
     * <p>
     * This method creates a default sRGB OutputIntent if none exists.
     *
     * @param document the PDF document to process
     */
    @VisibleForTesting
    void ensureOutputIntent(@NotNull PDDocument document) {
        COSDictionary catalog = document.getDocumentCatalog().getCOSObject();

        if (!catalog.containsKey(COSName.OUTPUT_INTENTS)) {
            // Create sRGB OutputIntent for PDF/A-4
            COSDictionary outputIntent = new COSDictionary();
            outputIntent.setItem(COSName.TYPE, COSName.OUTPUT_INTENT);
            outputIntent.setItem(COSName.S, COSName.getPDFName("GTS_PDFA1"));
            outputIntent.setString(COSName.OUTPUT_CONDITION_IDENTIFIER, "sRGB");
            outputIntent.setString(COSName.INFO, "sRGB IEC61966-2.1");
            outputIntent.setString(COSName.REGISTRY_NAME, "http://www.color.org");

            COSArray outputIntents = new COSArray();
            outputIntents.add(outputIntent);
            catalog.setItem(COSName.OUTPUT_INTENTS, outputIntents);

            logger.debug("Created default sRGB OutputIntent for PDF/A-4 compliance");
        } else {
            logger.debug("OutputIntent already exists, skipping creation");
        }
    }

    /**
     * Fixes the document information dictionary according to PDF/A-4 requirements.
     * <p>
     * According to ISO 19005-4:2020 clause 6.1.3:
     * <ul>
     *     <li>Test 4: The Info key shall not be present in the trailer dictionary unless there exists a PieceInfo entry</li>
     *     <li>Test 5: If a document information dictionary is present, it shall only contain a ModDate entry</li>
     * </ul>
     *
     * @param document the PDF document to process
     */
    @VisibleForTesting
    void fixDocumentInformation(@NotNull PDDocument document) {
        PDDocumentInformation info = document.getDocumentInformation();
        COSDictionary catalog = document.getDocumentCatalog().getCOSObject();

        // Check if PieceInfo exists in the document catalog
        boolean hasPieceInfo = catalog.containsKey(COSName.PIECE_INFO);

        if (!hasPieceInfo) {
            // If no PieceInfo exists, remove the Info dictionary entirely
            COSDictionary trailer = document.getDocument().getTrailer();
            trailer.removeItem(COSName.INFO);
            logger.debug("Removed Info key from trailer dictionary (no PieceInfo present)");
        } else if (info != null) {
            // If PieceInfo exists and Info is present, keep only ModDate
            Calendar modDate = info.getModificationDate();

            // Clear all information
            COSDictionary infoDictionary = info.getCOSObject();
            infoDictionary.clear();

            // Restore only ModDate if it was present
            if (modDate != null) {
                info.setModificationDate(modDate);
                logger.debug("Cleaned document information dictionary, keeping only ModDate");
            } else {
                // If no ModDate exists, set it to current time
                info.setModificationDate(Calendar.getInstance());
                logger.debug("Set ModDate to current time in document information dictionary");
            }
        }
    }

    /**
     * Fixes XMP metadata according to PDF/A-4 requirements using XML DOM parsing.
     * <p>
     * According to ISO 19005-4:2020 clause 6.7.3:
     * <ul>
     *     <li>Test 5: The value of "pdfaid:rev" shall be the four-digit year (e.g., "2020" not "4")</li>
     *     <li>Test 3: Files not conforming to PDF/A-4e or PDF/A-4f shall not provide "pdfaid:conformance"</li>
     * </ul>
     *
     * @param document    the PDF document to process
     * @param conformance the conformance level: "E" for engineering, "F" for embedded files, or null for basic (4u)
     */
    @VisibleForTesting
    void fixXmpMetadata(@NotNull PDDocument document, @Nullable String conformance) throws IOException {
        PDMetadata metadata = document.getDocumentCatalog().getMetadata();
        if (metadata == null) {
            logger.warn("No XMP metadata found in document");
            return;
        }

        try {
            // Read current metadata as string
            String metadataString = new String(metadata.toByteArray(), StandardCharsets.UTF_8);

            // Parse and fix XMP metadata using XML DOM
            String fixedMetadata = fixXmpMetadataXml(metadataString, conformance);

            if (!fixedMetadata.equals(metadataString)) {
                // Update metadata with fixed version
                metadata.importXMPMetadata(fixedMetadata.getBytes(StandardCharsets.UTF_8));
                logger.info("Updated XMP metadata for PDF/A-4 compliance");
            } else {
                logger.debug("No XMP metadata changes needed");
            }
        } catch (Exception e) {
            logger.error("Failed to process XMP metadata", e);
            throw new IOException("Failed to process XMP metadata", e);
        }
    }

    /**
     * Fixes XMP metadata XML content according to PDF/A-4 requirements.
     * Uses XML DOM parsing for reliable and maintainable metadata manipulation.
     *
     * @param xmpMetadata the original XMP metadata as XML string
     * @param conformance the conformance level: "E" for engineering, "F" for embedded files, or null for basic (4u)
     * @return the fixed XMP metadata as XML string
     * @throws TransformerException if XML parsing or transformation fails
     * @throws ParserConfigurationException if XML parsing fails
     * @throws IOException if XML parsing fails
     * @throws SAXException if XML parsing fails
     */
    @VisibleForTesting
    String fixXmpMetadataXml(@NotNull String xmpMetadata, @Nullable String conformance) throws TransformerException, ParserConfigurationException, IOException, SAXException {
        // Parse XML
        DocumentBuilderFactory documentBuilderFactory = createSecureDocumentBuilderFactory();
        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();

        // Extract the RDF content (between <?xpacket...?> tags)
        String rdfContent = extractRdfContent(xmpMetadata);
        Document document = documentBuilder.parse(new InputSource(new StringReader(rdfContent)));

        // Find all rdf:Description elements
        NodeList descriptions = document.getElementsByTagNameNS("http://www.w3.org/1999/02/22-rdf-syntax-ns#", "Description");

        boolean metadataModified = false;

        for (int i = 0; i < descriptions.getLength(); i++) {
            Element description = (Element) descriptions.item(i);

            // Check if this is a PDF/A identification element (has pdfaid:part attribute)
            String pdfaidPart = getAttributeValue(description, "pdfaid:part");

            if ("4".equals(pdfaidPart)) {
                // This is PDF/A-4 identification - fix it
                metadataModified |= fixPdfA4Identification(description, conformance);
            }
        }

        if (!metadataModified) {
            logger.debug("Not PDF/A-4 or no metadata changes needed");
            return xmpMetadata;
        }

        // Convert back to string with proper XMP packaging
        String fixedRdf = documentToString(document);
        return wrapWithXPacket(fixedRdf);
    }

    /**
     * Extracts RDF content from XMP metadata (removes xpacket processing instructions).
     * <p>
     * XMP metadata format:
     * <pre>
     * {@code
     * <?xpacket begin="..." id="..."?>
     * <rdf:RDF>...</rdf:RDF>
     * <?xpacket end="..."?>
     * }
     * </pre>
     * <p>
     * Uses XML DOM parsing to properly handle XML structure and remove processing instructions.
     *
     * @param xmpMetadata the full XMP metadata with xpacket tags
     * @return the RDF content without xpacket tags
     * @throws ParserConfigurationException if XML parser cannot be configured
     * @throws IOException if XML parsing fails
     * @throws SAXException if XML is malformed
     * @throws TransformerException if XML transformation fails
     */
    @VisibleForTesting
    String extractRdfContent(@NotNull String xmpMetadata) throws ParserConfigurationException, IOException, SAXException, TransformerException {
        // Parse the complete XMP metadata (including processing instructions)
        DocumentBuilderFactory secureDocumentBuilderFactory = createSecureDocumentBuilderFactory();
        DocumentBuilder documentBuilder = secureDocumentBuilderFactory.newDocumentBuilder();

        // Parse the XMP metadata as XML
        Document document = documentBuilder.parse(new InputSource(new StringReader(xmpMetadata)));

        // Serialize just the document element (RDF) without processing instructions
        TransformerFactory transformerFactory = createSecureTransformerFactory();
        Transformer transformer = transformerFactory.newTransformer();
        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
        transformer.setOutputProperty(OutputKeys.INDENT, "no");

        StringWriter writer = new StringWriter();
        // Transform only the document element (this excludes processing instructions)
        transformer.transform(new DOMSource(document.getDocumentElement()), new StreamResult(writer));

        return writer.toString().trim();
    }

    /**
     * Wraps RDF content with XMP packet processing instructions.
     * Generates a unique packet ID using UUID.
     * <p>
     * According to XMP Specification (ISO 16684-1), the xpacket begin attribute must contain
     * the Unicode BOM (U+FEFF) to indicate UTF-8 encoding for PDF/A compliance.
     *
     * @param rdfContent the RDF content to wrap
     * @return the complete XMP metadata with xpacket tags
     */
    @VisibleForTesting
    @NotNull String wrapWithXPacket(@NotNull String rdfContent) {
        // Generate unique packet ID (remove hyphens from UUID to match XMP packet ID format)
        String packetId = UUID.randomUUID().toString().replace("-", "");
        // UTF-8 BOM (U+FEFF) is required in the begin attribute for PDF/A compliance
        return "<?xpacket begin=\"\uFEFF\" id=\"" + packetId + "\"?>\n" +
               rdfContent + "\n" +
               "<?xpacket end=\"r\"?>";
    }

    /**
     * Fixes PDF/A-4 identification in an rdf:Description element.
     * <p>
     * According to ISO 19005-4:2020:
     * <ul>
     *     <li>pdfaid:conformance is required for PDF/A-4e and PDF/A-4f</li>
     *     <li>pdfaid:conformance shall not be present for PDF/A-4 (basic) and PDF/A-4u</li>
     * </ul>
     *
     * @param description the rdf:Description element to fix
     * @param conformance the conformance level: "E" for engineering, "F" for embedded files, or null for basic (4u)
     * @return true if any changes were made
     */
    @VisibleForTesting
    boolean fixPdfA4Identification(@NotNull Element description, @Nullable String conformance) {
        boolean modified = false;

        // Fix 1: Add or update pdfaid:rev to "2020"
        String currentRev = getAttributeValue(description, PDFAID_REV);
        if (currentRev == null || currentRev.isEmpty()) {
            // Add pdfaid:rev="2020"
            setPropertyValue(description, PDFAID_REV, PDF_A_4_REV_YEAR);
            logger.debug("Added pdfaid:rev=\"" + PDF_A_4_REV_YEAR + "\" to XMP metadata");
            modified = true;
        } else if (!PDF_A_4_REV_YEAR.equals(currentRev)) {
            // Update incorrect rev value
            setPropertyValue(description, PDFAID_REV, PDF_A_4_REV_YEAR);
            logger.debug("Updated pdfaid:rev from \"" + currentRev + "\" to \"" + PDF_A_4_REV_YEAR + "\"");
            modified = true;
        }

        // Fix 2: Handle pdfaid:conformance based on conformance level
        String currentConformance = getAttributeValue(description, "pdfaid:conformance");
        if (conformance != null) {
            // PDF/A-4e and PDF/A-4f require conformance attribute
            if (!conformance.equals(currentConformance)) {
                setPropertyValue(description, "pdfaid:conformance", conformance);
                logger.debug("Set pdfaid:conformance=\"" + conformance + "\" in XMP metadata");
                modified = true;
            }
        } else {
            // PDF/A-4 (basic) and PDF/A-4u shall not have conformance property
            if (hasProperty(description, "pdfaid:conformance")) {
                removeProperty(description, "pdfaid:conformance");
                logger.debug("Removed pdfaid:conformance from XMP metadata");
                modified = true;
            }
        }

        return modified;
    }

    /**
     * Gets attribute or child element value from element, handling namespace prefixes.
     * <p>
     * In XMP/RDF, property values can be expressed either as attributes or as child elements.
     * This method checks both forms.
     *
     * @param element       the XML element
     * @param attributeName the attribute/element name (may include namespace prefix like "pdfaid:part")
     * @return the attribute/element value, or null if not found
     */
    @VisibleForTesting
    @Nullable String getAttributeValue(@NotNull Element element, @NotNull String attributeName) {
        // Try as attribute with namespace prefix
        if (element.hasAttribute(attributeName)) {
            return element.getAttribute(attributeName);
        }

        // Try without prefix (in case of namespace URI)
        String[] parts = attributeName.split(":");
        if (parts.length == 2) {
            String namespaceURI = getNamespaceUriForPrefix(parts[0]);
            if (namespaceURI != null) {
                if (element.hasAttributeNS(namespaceURI, parts[1])) {
                    return element.getAttributeNS(namespaceURI, parts[1]);
                }

                // Try as child element (XMP/RDF allows property values as child elements)
                NodeList children = element.getElementsByTagNameNS(namespaceURI, parts[1]);
                if (children.getLength() > 0) {
                    return children.item(0).getTextContent();
                }

                // Also try without namespace for child elements
                children = element.getElementsByTagName(attributeName);
                if (children.getLength() > 0) {
                    return children.item(0).getTextContent();
                }
            }
        }

        return null;
    }

    /**
     * Sets a property value on an element, handling both attribute and child element forms.
     * <p>
     * If the property exists as a child element, it will be updated. Otherwise, it will be set as an attribute.
     *
     * @param element       the XML element
     * @param attributeName the attribute/element name (may include namespace prefix like "pdfaid:rev")
     * @param value         the value to set
     */
    @VisibleForTesting
    void setPropertyValue(@NotNull Element element, @NotNull String attributeName, @NotNull String value) {
        String[] parts = attributeName.split(":");
        if (parts.length == 2) {
            String namespaceURI = getNamespaceUriForPrefix(parts[0]);
            if (namespaceURI != null) {
                // Check if child element exists
                NodeList children = element.getElementsByTagNameNS(namespaceURI, parts[1]);
                if (children.getLength() > 0) {
                    // Update existing child element
                    children.item(0).setTextContent(value);
                    return;
                }

                // Also check without namespace
                children = element.getElementsByTagName(attributeName);
                if (children.getLength() > 0) {
                    children.item(0).setTextContent(value);
                    return;
                }
            }
        }

        // Set as attribute (default behavior)
        element.setAttribute(attributeName, value);
    }

    /**
     * Removes a property from an element, handling both attribute and child element forms.
     *
     * @param element       the XML element
     * @param attributeName the attribute/element name (may include namespace prefix like "pdfaid:conformance")
     */
    @VisibleForTesting
    void removeProperty(@NotNull Element element, @NotNull String attributeName) {
        // Remove attribute
        if (element.hasAttribute(attributeName)) {
            element.removeAttribute(attributeName);
        }

        // Remove child elements
        String[] parts = attributeName.split(":");
        if (parts.length == 2) {
            String namespaceURI = getNamespaceUriForPrefix(parts[0]);
            if (namespaceURI != null) {
                NodeList children = element.getElementsByTagNameNS(namespaceURI, parts[1]);
                while (children.getLength() > 0) {
                    element.removeChild(children.item(0));
                }

                children = element.getElementsByTagName(attributeName);
                while (children.getLength() > 0) {
                    element.removeChild(children.item(0));
                }
            }
        }
    }

    /**
     * Checks if a property exists on an element, either as attribute or child element.
     *
     * @param element       the XML element
     * @param attributeName the attribute/element name (may include namespace prefix)
     * @return true if the property exists
     */
    @VisibleForTesting
    boolean hasProperty(@NotNull Element element, @NotNull String attributeName) {
        return getAttributeValue(element, attributeName) != null;
    }

    /**
     * Returns namespace URI for common XMP prefixes.
     *
     * @param prefix the namespace prefix (e.g., "pdfaid", "pdf", "rdf")
     * @return the namespace URI, or null if unknown prefix
     */
    @VisibleForTesting
    String getNamespaceUriForPrefix(@NotNull String prefix) {
        return switch (prefix) {
            case "pdfaid" -> "http://www.aiim.org/pdfa/ns/id/";
            case "pdf" -> "http://ns.adobe.com/pdf/1.3/";
            case "rdf" -> "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
            case "dc" -> "http://purl.org/dc/elements/1.1/";
            case "xmp" -> "http://ns.adobe.com/xap/1.0/";
            default -> null;
        };
    }

    /**
     * Converts XML Document to string.
     *
     * @param doc the XML document
     * @return the XML as string
     * @throws TransformerException if transformation fails
     */
    @VisibleForTesting
    String documentToString(@NotNull Document doc) throws TransformerException {
        TransformerFactory transformerFactory = createSecureTransformerFactory();
        Transformer transformer = transformerFactory.newTransformer();
        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
        transformer.setOutputProperty(OutputKeys.INDENT, "no");

        StringWriter writer = new StringWriter();
        transformer.transform(new DOMSource(doc), new StreamResult(writer));
        return writer.toString();
    }

    /**
     * Creates a secure DocumentBuilderFactory with XXE protection enabled.
     * Disables external entity processing to prevent XXE (XML External Entity) attacks.
     *
     * @return a secure DocumentBuilderFactory instance
     * @throws ParserConfigurationException if configuration fails
     */
    private static DocumentBuilderFactory createSecureDocumentBuilderFactory() throws ParserConfigurationException {
        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
        documentBuilderFactory.setNamespaceAware(true);

        // Disable external entity processing to prevent XXE attacks
        documentBuilderFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        documentBuilderFactory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
        documentBuilderFactory.setFeature("http://xml.org/sax/features/external-general-entities", false);
        documentBuilderFactory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
        documentBuilderFactory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
        documentBuilderFactory.setXIncludeAware(false);
        documentBuilderFactory.setExpandEntityReferences(false);

        return documentBuilderFactory;
    }

    /**
     * Creates a secure TransformerFactory with XXE protection enabled.
     * Disables external entity processing to prevent XXE (XML External Entity) attacks.
     *
     * @return a secure TransformerFactory instance
     * @throws TransformerException if configuration fails
     */
    private static TransformerFactory createSecureTransformerFactory() throws TransformerException {
        TransformerFactory transformerFactory = TransformerFactory.newInstance();

        // Disable external entity processing to prevent XXE attacks
        transformerFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
        transformerFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, "");

        return transformerFactory;
    }
}
