package ch.sbb.polarion.extension.pdf_exporter.util;

import com.polarion.core.util.logging.Logger;
import lombok.experimental.UtilityClass;
import org.apache.pdfbox.Loader;
import org.apache.pdfbox.cos.COSArray;
import org.apache.pdfbox.cos.COSDictionary;
import org.apache.pdfbox.cos.COSName;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.PDDocumentInformation;
import org.apache.pdfbox.pdmodel.common.PDMetadata;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.VisibleForTesting;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Calendar;

/**
 * Utility class for processing PDF/A-4 documents to ensure compliance with ISO 19005-4:2020 specification.
 * <p>
 * This processor fixes common compliance issues that may be present in PDF/A-4 documents generated by WeasyPrint
 * or after PDF merging operations:
 * <ul>
 *     <li>Updates PDF version to 2.0 (PDF/A-4 requires PDF 2.0 or higher)</li>
 *     <li>Manually fixes the PDF file header to "%PDF-2.0" (workaround for PDFBox 3.x limitation)</li>
 *     <li>Ensures PDF/A OutputIntent exists (creates default sRGB OutputIntent if missing)</li>
 *     <li>Removes non-compliant entries from document information dictionary (keeping only ModDate)</li>
 *     <li>Removes the Info key from trailer dictionary when no PieceInfo exists in document catalog</li>
 *     <li>Fixes XMP metadata to use correct pdfaid:rev format (four-digit year instead of revision number)</li>
 *     <li>Handles pdfaid:conformance based on conformance level:
 *         <ul>
 *             <li>Sets pdfaid:conformance="E" for PDF/A-4e (engineering)</li>
 *             <li>Sets pdfaid:conformance="F" for PDF/A-4f (embedded files)</li>
 *             <li>Removes pdfaid:conformance for PDF/A-4u (not allowed)</li>
 *         </ul>
 *     </li>
 * </ul>
 * <p>
 * Note: This processor creates a new PDF document with version 2.0 and copies all content from the original,
 * as PDFBox 3.x does not reliably update the PDF version in the file header. This approach also helps restore
 * OutputIntent that may be lost during PDF merging operations.
 */
@UtilityClass
public class PdfA4Processor {
    private static final Logger logger = Logger.getLogger(PdfA4Processor.class);
    private static final String PDF_A_4_REV_YEAR = "2020";
    private static final String PDFAID_REV = "pdfaid:rev";
    private static final String PDFAID_CONFORMANCE = "pdfaid:conformance";

    /**
     * Processes a PDF/A-4 document to fix compliance issues according to ISO 19005-4:2020.
     * <p>
     * This method creates a new PDF document with version 2.0 and copies all content from the original,
     * as PDFBox does not reliably update the PDF version in the file header when using save().
     *
     * @param pdfBytes the original PDF content
     * @return the processed PDF content with compliance fixes applied
     * @throws IOException if an error occurs during PDF processing
     */
    public byte[] processPdfA4(byte[] pdfBytes) throws IOException {
        return processPdfA4(pdfBytes, null);
    }

    /**
     * Processes a PDF/A-4 document to fix compliance issues according to ISO 19005-4:2020.
     * <p>
     * This method creates a new PDF document with version 2.0 and copies all content from the original,
     * as PDFBox does not reliably update the PDF version in the file header when using save().
     *
     * @param pdfBytes    the original PDF content
     * @param conformance the conformance level: "E" for engineering, "F" for embedded files, or null for basic (4u)
     * @return the processed PDF content with compliance fixes applied
     * @throws IOException if an error occurs during PDF processing
     */
    public byte[] processPdfA4(byte[] pdfBytes, @Nullable String conformance) throws IOException {
        try (PDDocument originalDoc = Loader.loadPDF(pdfBytes);
             PDDocument newDoc = new PDDocument();
             ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {

            // Copy all pages from original to new document
            for (int i = 0; i < originalDoc.getNumberOfPages(); i++) {
                newDoc.addPage(originalDoc.getPage(i));
            }

            // Copy document catalog properties
            copyDocumentCatalog(originalDoc, newDoc);

            // Ensure OutputIntent exists (create sRGB OutputIntent if missing)
            ensureOutputIntent(newDoc);

            // Fix document information dictionary
            fixDocumentInformation(newDoc);

            // Fix XMP metadata
            fixXmpMetadata(newDoc, conformance);

            // IMPORTANT: Set PDF version to 2.0 AFTER all content has been copied
            // This must be done last to prevent PDFBox from auto-downgrading the version
            newDoc.setVersion(2.0f);

            // Also set version in catalog dictionary
            COSDictionary catalog = newDoc.getDocumentCatalog().getCOSObject();
            catalog.setItem(COSName.VERSION, COSName.getPDFName("2.0"));

            logger.debug("Set PDF version to 2.0 for PDF/A-4 compliance");

            // Save the modified document
            newDoc.save(outputStream);
            byte[] pdfContent = outputStream.toByteArray();

            // WORKAROUND: PDFBox 3.x doesn't always write PDF 2.0 in the file header
            // Manually fix the header if needed
            return fixPdfHeader(pdfContent);
        }
    }

    /**
     * Fixes the PDF header to ensure it starts with "%PDF-2.0".
     * <p>
     * This is a workaround for PDFBox 3.x which doesn't always write PDF 2.0
     * in the file header even when setVersion(2.0f) is called.
     *
     * @param pdfBytes the PDF content
     * @return the PDF content with fixed header
     */
    @VisibleForTesting
    byte[] fixPdfHeader(byte[] pdfBytes) {
        // Check if header needs fixing
        if (pdfBytes.length < 10) {
            return pdfBytes; // PDF too small, leave as is
        }

        // Read current header
        String header = new String(pdfBytes, 0, Math.min(20, pdfBytes.length), StandardCharsets.UTF_8);
        if (header.startsWith("%PDF-2.")) {
            return pdfBytes; // Already PDF 2.x, no fix needed
        }

        if (!header.startsWith("%PDF-1.")) {
            logger.warn("Unexpected PDF header: " + header.substring(0, Math.min(10, header.length())));
            return pdfBytes; // Unexpected format, leave as is
        }

        // Find the end of the version line (EOL marker)
        int eolIndex = -1;
        for (int i = 0; i < Math.min(20, pdfBytes.length); i++) {
            if (pdfBytes[i] == '\n' || pdfBytes[i] == '\r') {
                eolIndex = i;
                break;
            }
        }

        if (eolIndex == -1) {
            logger.warn("Could not find EOL marker in PDF header");
            return pdfBytes; // No EOL found, leave as is
        }

        // Replace the header with "%PDF-2.0"
        byte[] newPdfBytes = new byte[pdfBytes.length];
        byte[] newHeader = "%PDF-2.0".getBytes(StandardCharsets.UTF_8);

        // Copy new header
        System.arraycopy(newHeader, 0, newPdfBytes, 0, newHeader.length);

        // Copy the rest of the PDF (from EOL onwards)
        System.arraycopy(pdfBytes, eolIndex, newPdfBytes, newHeader.length, pdfBytes.length - eolIndex);

        logger.debug("Fixed PDF header from PDF 1.x to PDF 2.0");
        return newPdfBytes;
    }

    /**
     * Copies document catalog properties from source to destination document.
     * This includes metadata, OutputIntents, Names (for embedded files), and other catalog-level properties.
     *
     * @param source      the source PDF document
     * @param destination the destination PDF document
     * @throws IOException if an error occurs during copying
     */
    @VisibleForTesting
    void copyDocumentCatalog(@NotNull PDDocument source, @NotNull PDDocument destination) throws IOException {
        copyXmpMetadata(source, destination);
        copyOutputIntents(source, destination);
        copyDocumentInformation(source, destination);
        copyEmbeddedFiles(source, destination);
        logger.debug("Copied document catalog from source to destination");
    }

    /**
     * Copies XMP metadata from source to destination document.
     *
     * @param source      the source PDF document
     * @param destination the destination PDF document
     * @throws IOException if an error occurs during copying
     */
    @VisibleForTesting
    void copyXmpMetadata(@NotNull PDDocument source, @NotNull PDDocument destination) throws IOException {
        PDMetadata sourceMetadata = source.getDocumentCatalog().getMetadata();
        if (sourceMetadata != null) {
            PDMetadata destMetadata = new PDMetadata(destination);
            destMetadata.importXMPMetadata(sourceMetadata.toByteArray());
            destination.getDocumentCatalog().setMetadata(destMetadata);
            logger.debug("Copied XMP metadata from source to destination");
        }
    }

    /**
     * Copies OutputIntents from source to destination document.
     * OutputIntents are critical for PDF/A compliance.
     *
     * @param source      the source PDF document
     * @param destination the destination PDF document
     */
    @VisibleForTesting
    void copyOutputIntents(@NotNull PDDocument source, @NotNull PDDocument destination) {
        COSDictionary sourceCatalog = source.getDocumentCatalog().getCOSObject();
        COSDictionary destCatalog = destination.getDocumentCatalog().getCOSObject();

        if (sourceCatalog.containsKey(COSName.OUTPUT_INTENTS)) {
            destCatalog.setItem(COSName.OUTPUT_INTENTS, sourceCatalog.getItem(COSName.OUTPUT_INTENTS));
            logger.debug("Copied OutputIntents from source to destination");
        }
    }

    /**
     * Copies document information from source to destination document.
     * Only ModificationDate is preserved to ensure PDF/A-4 compliance.
     *
     * @param source      the source PDF document
     * @param destination the destination PDF document
     */
    @VisibleForTesting
    void copyDocumentInformation(@NotNull PDDocument source, @NotNull PDDocument destination) {
        PDDocumentInformation sourceInfo = source.getDocumentInformation();
        if (sourceInfo != null) {
            // Copy only the fields we want to preserve
            PDDocumentInformation destInfo = new PDDocumentInformation();
            if (sourceInfo.getModificationDate() != null) {
                destInfo.setModificationDate(sourceInfo.getModificationDate());
            }
            destination.setDocumentInformation(destInfo);
            logger.debug("Copied document information from source to destination");
        }
    }

    /**
     * Copies embedded files (Names dictionary) from source to destination document.
     * This is required for PDF/A-4f compliance which mandates the EmbeddedFiles key.
     *
     * @param source      the source PDF document
     * @param destination the destination PDF document
     */
    @VisibleForTesting
    void copyEmbeddedFiles(@NotNull PDDocument source, @NotNull PDDocument destination) {
        COSDictionary sourceCatalog = source.getDocumentCatalog().getCOSObject();
        COSDictionary destCatalog = destination.getDocumentCatalog().getCOSObject();

        if (sourceCatalog.containsKey(COSName.NAMES)) {
            destCatalog.setItem(COSName.NAMES, sourceCatalog.getItem(COSName.NAMES));
            logger.debug("Copied Names dictionary (including EmbeddedFiles) from source to destination");
        }
    }

    /**
     * Ensures that the PDF document has an OutputIntent.
     * <p>
     * According to ISO 19005-4:2020 clause 6.2.9 and 6.2.4.3:
     * <ul>
     *     <li>If the document does not contain a PDF/A output intent, pages with transparency
     *     must have page-level output intent or Group key with CS entry</li>
     *     <li>DeviceRGB requires either DefaultRGB colour space, transparency blending space,
     *     or PDF/A OutputIntent with RGB destination profile</li>
     * </ul>
     * <p>
     * This method creates a default sRGB OutputIntent if none exists.
     *
     * @param document the PDF document to process
     */
    @VisibleForTesting
    void ensureOutputIntent(@NotNull PDDocument document) {
        COSDictionary catalog = document.getDocumentCatalog().getCOSObject();

        if (!catalog.containsKey(COSName.OUTPUT_INTENTS)) {
            // Create sRGB OutputIntent for PDF/A-4
            COSDictionary outputIntent = new COSDictionary();
            outputIntent.setItem(COSName.TYPE, COSName.OUTPUT_INTENT);
            outputIntent.setItem(COSName.S, COSName.getPDFName("GTS_PDFA1"));
            outputIntent.setString(COSName.OUTPUT_CONDITION_IDENTIFIER, "sRGB");
            outputIntent.setString(COSName.INFO, "sRGB IEC61966-2.1");
            outputIntent.setString(COSName.REGISTRY_NAME, "http://www.color.org");

            COSArray outputIntents = new COSArray();
            outputIntents.add(outputIntent);
            catalog.setItem(COSName.OUTPUT_INTENTS, outputIntents);

            logger.debug("Created default sRGB OutputIntent for PDF/A-4 compliance");
        } else {
            logger.debug("OutputIntent already exists, skipping creation");
        }
    }

    /**
     * Fixes the document information dictionary according to PDF/A-4 requirements.
     * <p>
     * According to ISO 19005-4:2020 clause 6.1.3:
     * <ul>
     *     <li>Test 4: The Info key shall not be present in the trailer dictionary unless there exists a PieceInfo entry</li>
     *     <li>Test 5: If a document information dictionary is present, it shall only contain a ModDate entry</li>
     * </ul>
     *
     * @param document the PDF document to process
     */
    @VisibleForTesting
    void fixDocumentInformation(@NotNull PDDocument document) {
        PDDocumentInformation info = document.getDocumentInformation();
        COSDictionary catalog = document.getDocumentCatalog().getCOSObject();

        // Check if PieceInfo exists in the document catalog
        boolean hasPieceInfo = catalog.containsKey(COSName.PIECE_INFO);

        if (!hasPieceInfo) {
            // If no PieceInfo exists, remove the Info dictionary entirely
            COSDictionary trailer = document.getDocument().getTrailer();
            trailer.removeItem(COSName.INFO);
            logger.debug("Removed Info key from trailer dictionary (no PieceInfo present)");
        } else if (info != null) {
            // If PieceInfo exists and Info is present, keep only ModDate
            Calendar modDate = info.getModificationDate();

            // Clear all information
            COSDictionary infoDictionary = info.getCOSObject();
            infoDictionary.clear();

            // Restore only ModDate if it was present
            if (modDate != null) {
                info.setModificationDate(modDate);
                logger.debug("Cleaned document information dictionary, keeping only ModDate");
            } else {
                // If no ModDate exists, set it to current time
                info.setModificationDate(Calendar.getInstance());
                logger.debug("Set ModDate to current time in document information dictionary");
            }
        }
    }

    /**
     * Fixes XMP metadata according to PDF/A-4 requirements using XML DOM parsing.
     * <p>
     * According to ISO 19005-4:2020 clause 6.7.3:
     * <ul>
     *     <li>Test 5: The value of "pdfaid:rev" shall be the four-digit year (e.g., "2020" not "4")</li>
     *     <li>Test 3: Files not conforming to PDF/A-4e or PDF/A-4f shall not provide "pdfaid:conformance"</li>
     * </ul>
     *
     * @param document    the PDF document to process
     * @param conformance the conformance level: "E" for engineering, "F" for embedded files, or null for basic (4u)
     */
    @VisibleForTesting
    void fixXmpMetadata(@NotNull PDDocument document, @Nullable String conformance) throws IOException {
        PDMetadata metadata = document.getDocumentCatalog().getMetadata();
        if (metadata == null) {
            logger.warn("No XMP metadata found in document");
            return;
        }

        try {
            // Read current metadata as string
            String metadataString = new String(metadata.toByteArray(), StandardCharsets.UTF_8);

            // Parse and fix XMP metadata using XML DOM
            String fixedMetadata = fixXmpMetadataXml(metadataString, conformance);

            if (!fixedMetadata.equals(metadataString)) {
                // Update metadata with fixed version
                metadata.importXMPMetadata(fixedMetadata.getBytes(StandardCharsets.UTF_8));
                logger.info("Updated XMP metadata for PDF/A-4 compliance");
            } else {
                logger.debug("No XMP metadata changes needed");
            }
        } catch (Exception e) {
            logger.error("Failed to process XMP metadata", e);
            throw new IOException("Failed to process XMP metadata", e);
        }
    }

    /**
     * Fixes XMP metadata XML content according to PDF/A-4 requirements.
     * Uses XML DOM parsing for reliable and maintainable metadata manipulation.
     *
     * @param xmpMetadata the original XMP metadata as XML string
     * @param conformance the conformance level: "E" for engineering, "F" for embedded files, or null for basic (4u)
     * @return the fixed XMP metadata as XML string
     * @throws TransformerException if XML parsing or transformation fails
     * @throws ParserConfigurationException if XML parsing fails
     * @throws IOException if XML parsing fails
     * @throws SAXException if XML parsing fails
     */
    @VisibleForTesting
    String fixXmpMetadataXml(@NotNull String xmpMetadata, @Nullable String conformance) throws TransformerException, ParserConfigurationException, IOException, SAXException {
        // Extract the RDF content (between <?xpacket...?> tags)
        String rdfContent = XmpMetadataUtils.extractRdfContent(xmpMetadata);

        // Parse XML
        Document document = XmpMetadataUtils.parseXml(rdfContent);

        // Find all rdf:Description elements
        NodeList descriptions = XmpMetadataUtils.getRdfDescriptions(document);

        boolean metadataModified = false;

        for (int i = 0; i < descriptions.getLength(); i++) {
            Element description = (Element) descriptions.item(i);

            // Check if this is a PDF/A identification element (has pdfaid:part attribute)
            String pdfaidPart = XmpMetadataUtils.getAttributeValue(description, "pdfaid:part");

            if ("4".equals(pdfaidPart)) {
                // This is PDF/A-4 identification - fix it
                metadataModified |= fixPdfA4Identification(description, conformance);
            }
        }

        if (!metadataModified) {
            logger.debug("Not PDF/A-4 or no metadata changes needed");
            return xmpMetadata;
        }

        // Convert back to string with proper XMP packaging
        String fixedRdf = XmpMetadataUtils.documentToString(document);
        return XmpMetadataUtils.wrapWithXPacket(fixedRdf);
    }

    /**
     * Fixes PDF/A-4 identification in an rdf:Description element.
     * <p>
     * According to ISO 19005-4:2020:
     * <ul>
     *     <li>pdfaid:conformance is required for PDF/A-4e and PDF/A-4f</li>
     *     <li>pdfaid:conformance shall not be present for PDF/A-4 (basic) and PDF/A-4u</li>
     * </ul>
     *
     * @param description the rdf:Description element to fix
     * @param conformance the conformance level: "E" for engineering, "F" for embedded files, or null for basic (4u)
     * @return true if any changes were made
     */
    @VisibleForTesting
    boolean fixPdfA4Identification(@NotNull Element description, @Nullable String conformance) {
        boolean modified = false;

        // Fix 1: Add or update pdfaid:rev to "2020"
        String currentRev = XmpMetadataUtils.getAttributeValue(description, PDFAID_REV);
        if (currentRev == null || currentRev.isEmpty()) {
            // Add pdfaid:rev="2020"
            XmpMetadataUtils.setPropertyValue(description, PDFAID_REV, PDF_A_4_REV_YEAR);
            logger.debug("Added pdfaid:rev=\"" + PDF_A_4_REV_YEAR + "\" to XMP metadata");
            modified = true;
        } else if (!PDF_A_4_REV_YEAR.equals(currentRev)) {
            // Update incorrect rev value
            XmpMetadataUtils.setPropertyValue(description, PDFAID_REV, PDF_A_4_REV_YEAR);
            logger.debug("Updated pdfaid:rev from \"" + currentRev + "\" to \"" + PDF_A_4_REV_YEAR + "\"");
            modified = true;
        }

        // Fix 2: Handle pdfaid:conformance based on conformance level
        String currentConformance = XmpMetadataUtils.getAttributeValue(description, PDFAID_CONFORMANCE);
        if (conformance != null) {
            // PDF/A-4e and PDF/A-4f require conformance attribute
            if (!conformance.equals(currentConformance)) {
                XmpMetadataUtils.setPropertyValue(description, PDFAID_CONFORMANCE, conformance);
                logger.debug("Set pdfaid:conformance=\"" + conformance + "\" in XMP metadata");
                modified = true;
            }
        } else {
            // PDF/A-4 (basic) and PDF/A-4u shall not have conformance property
            if (XmpMetadataUtils.hasProperty(description, PDFAID_CONFORMANCE)) {
                XmpMetadataUtils.removeProperty(description, PDFAID_CONFORMANCE);
                logger.debug("Removed pdfaid:conformance from XMP metadata");
                modified = true;
            }
        }

        return modified;
    }
}
